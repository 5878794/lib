{"version":3,"sources":["asyncRunner.es6"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoDA,CAAC,YAAU;;;;;;;;AAQP,QAAI,QAAQ,EAAZ;QACI,QAAQ,CADZ;QAEI,MAAM,CAFV;QAGI,OAAO,EAHX;;AAMA,WAAO,WAAP,GAAqB;AACjB,cAAK,gBAAU;AACX;;AAEA,gBAAI,QAAQ,IAAZ;AACA,uBAAW,YAAU;AACjB,sBAAM,EAAN;;AAEH,aAHD,EAGE,CAHF;AAIH,SATgB;AAUjB,YAAG,cAAU;;AAET,gBAAG,SAAS,GAAZ,EAAgB;AAAC;AAAQ;;AAEzB,gBAAG,MAAM,MAAN,IAAgB,CAAnB,EAAqB;AAAC;AAAQ;;AAE9B,gBAAI,QAAQ,SAAR,KAAQ,GAAU;AAClB,oBAAI,MAAM,MAAM,KAAN,EAAV;oBACI,KAAK,IAAI,EADb;;AAGA;AACA;AACH,aAND;;AAQA;;;AAGA,mBAAM,MAAM,MAAN,IAAgB,CAAhB,IAAqB,MAAM,CAAN,EAAS,KAApC,EAA0C;AACtC;AACH;AACJ,SA9BgB;AA+BjB,aAAI,aAAS,GAAT,EAAa;AACb,iBAAI,IAAI,IAAE,CAAN,EAAQ,IAAE,IAAI,MAAlB,EAAyB,IAAE,CAA3B,EAA6B,GAA7B,EAAiC;AAC7B,sBAAM,IAAN,CAAW,IAAI,CAAJ,CAAX;AACH;AACD,iBAAK,EAAL;AACH,SApCgB;AAqCjB,kBAAS,kBAAS,GAAT,EAAa,GAAb,EAAiB;AACtB,iBAAK,GAAL,IAAY,GAAZ;AACH,SAvCgB;AAwCjB,iBAAQ,iBAAS,GAAT,EAAa;AACjB,mBAAO,KAAK,GAAL,CAAP;AACH;;AA1CgB,KAArB;AA6CH,CA3DD","file":"asyncRunner-compiled.js","sourcesContent":["\n//异步执行队列方式\n\n\n//函数定义\n//函数结束的时候需要执行  DEVICE.asyncRunner.next();  触发队列中的下一个函数\n//保存数据    DEVICE.asyncRunner.saveData(\"a\",{a:1});\n//获取数据    var data = DEVICE.asyncRunner.getData(\"a\");\n\n\n//var a = {\n//    a:function(){\n//        setTimeout(function(){\n//            console.log(\"a\");\n//            DEVICE.asyncRunner.saveData(\"a\",{a:1});\n//            DEVICE.asyncRunner.next();\n//        },100);\n//    },\n//    b:function(){\n//        setTimeout(function(){\n//            var data = DEVICE.asyncRunner.getData(\"a\");\n//            console.log(data);\n//            DEVICE.asyncRunner.next();\n//        },100);\n//    },\n//    c:function(){setTimeout(function(){console.log(\"c\");DEVICE.asyncRunner.next();},100);},\n//    d:function(){setTimeout(function(){console.log(\"d\");DEVICE.asyncRunner.next();},0);},\n//    e:function(){setTimeout(function(){console.log(\"e\");DEVICE.asyncRunner.next();},100);},\n//    f:function(){setTimeout(function(){console.log(\"f\");DEVICE.asyncRunner.next();},0);},\n//    g:function(){setTimeout(function(){console.log(\"g\");DEVICE.asyncRunner.next();},100);}\n//};\n//\n//\n//执行方式\n//$(document).ready(function(){\n//    DEVICE.asyncRunner.run([\n//        {\n//            fn:a.a,           //需要执行的函数名\n//            async:false        //是否异步执行。 true：不会等待上一个同步函数的结束就开始执行。\n//        },\n//        {fn:a.b,async:true},\n//        {fn:a.c,async:false},\n//        {fn:a.d,async:false},\n//        {fn:a.e,async:false},\n//        {fn:a.f,async:false}\n//    ])\n//});\n\n\n\n\n\n(function(){\n    //let event = document.createEvent('Event');\n    //event.initEvent(\"asyncRunner\",true,true);\n    //\n    //document.addEventListener(\"asyncRunner\",function(){\n    //    DEVICE.asyncRunner.go();\n    //},false);\n\n    let cache = [],\n        start = 0,\n        end = 0,\n        data = {};\n\n\n    DEVICE.asyncRunner = {\n        next:function(){\n            end++;\n\n            let _this = this;\n            setTimeout(function(){\n                _this.go();\n                //document.dispatchEvent(event);\n            },0)\n        },\n        go:function(){\n\n            if(start != end){return;}\n\n            if(cache.length == 0){return;}\n\n            var runFn = function(){\n                let obj = cache.shift(),\n                    fn = obj.fn;\n\n                start++;\n                fn();\n            };\n\n            runFn();\n\n            //获取下一个函数的状态是否是异步\n            while(cache.length != 0 && cache[0].async){\n                runFn();\n            }\n        },\n        run:function(obj){\n            for(var i=0,l=obj.length;i<l;i++){\n                cache.push(obj[i]);\n            }\n            this.go();\n        },\n        saveData:function(key,val){\n            data[key] = val;\n        },\n        getData:function(key){\n            return data[key];\n        }\n\n    };\n})();\n\n"]}